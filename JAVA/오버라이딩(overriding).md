# ✏오버라이딩  
조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도  
하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.  
  
참고- override의 사전적 의미는 '~위에 덮어쓰다'이다.  

### 오버라이딩의 조건  
오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야한다.  
그래서 오버라이딩이 성립하기 위해서는 다음과 같은 조건을 만족해야한다.  

> 자손클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와  
> -이름이 같아야 한다.  
> -매개변수가 같아야한다.  
> -반환타입이 같아야한다.  

**다만 접근제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.  

#### 1.접근 제어자는 조상 클래스의 메서드보다 좋은 범위로 변경할 수 없다.  
만일 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는  
접근 제어자가 protected나 public 이어야 함. 대부분 같은 범위의 접근 제어자 사용.  접근 제어자의 접근 범위를  
넓은 것에서 좋은 것 순으로 나열 public->protected,(default),private이다.  

#### 2.조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.  
throws Exception의 수가 조상이 더 많아야함.  
단*개수의 문제가 아닌 Exception이라는 예외는 최고의 조상이므로 많은 개수의 예외를 던질 수 있도록 선언한 것이기 때문에  
주의해야함 

> 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때  
> 1.접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.(public,private등)    
> 2.예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.  
> 3.인스턴스메서드를 static메서드로 또는 그 반대로 변경 할 수 없다.  

여기서 질문? 조상 클래스에 정의된 static메서드 같은 경우는 자손 클래스에서 똑같은 이름의 static메서드로 정의가능한가?  
답변: 가능하지만 이것은 각 클래스에 별개의 static메서드를 정의한 것일 뿐 오버라이딩이 아님, static멤버들은 자신들이  
정의된 클래스에 묶여있다고 생각해라.  

--- 

## 오버로딩 vs 오버라이딩  
오버로딩과 오버라이딩은 서로 혼동하기 쉽지만 사실 그차이는 명백하다. 오버로딩은 기존에 없는 새로운  
메서드를 추가하는 것이고, 오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.  

> 오버로딩(overloading) 기존에 없는 새로운 메서드를 정의하는 것(new).  
> 오버라이딩(overriding) 상속받은 메서드의 내용을 변경하는 것(change, modify). 


--- 

## super  
super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.  멤버변수와 지역변수의  
이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.  
조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super대신 this를 사용할 수 있다.그래도 조상 클래스의  
멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이 좋다.  
*조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다.   

static메서드는 인스턴스와 관련이 없다.그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스 메서드에서만  
사용할 수 있다.  


```java
class ProductTest {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}

class Parent {
	int x=10;
}

class Child extends Parent {
	void method() {
		System.out.println("x=" + x);
		System.out.println("this.x=" + this.x);
		System.out.println("super.x="+ super.x);
    //이경우 x,this.x,super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력되었다.  
	}
}

```
실행결과:  
x=10  
this.x=10  
super.x=10  

```java
class ProductTest {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}
class Parent {
	int x=10;	//같은이름의 조상 멤버변수  
}

class Child extends Parent {
	int x=20;   //같은이름의 자손 멤버변수  

	void method() {
		System.out.println("x=" + x);
		System.out.println("this.x=" + this.x);
		System.out.println("super.x="+ super.x);	//조상클래스의 멤버변수의 값을 출력  
	}   //이처럼 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복해서 정의하는 것이 가능하며  
      //참조변수 super를 이용해서 서로 구별할 수 있다.   
}
```
실행결과:  
x=20  
this.x=20  
super.x=10  

## super() - 조상 클래스의 생성자  
this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만,  
super()는 조상 클래스의 생성자를 호출하는데 사용된다.  
*생성자의 첫줄에서 조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로  
조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.  
Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야한다.  
그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super();'를 자동적으로 추가할 것이다.  

> Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자,this() 또는 super(),를 호출해야 한다.  
> 그렇지 않으면 컴파일러가 자동적으로 'super();를 생성자의 첫줄에 삽입한다.     






