
# ✏인터페이스  
인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상 클래스보다 추상화정도가 높아서. 
추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.   
*추상클래스를 부분적으로만 완성된 ‘미완성 설계도’라고 한다면 인터페이스는 구현된 것은 무것도 없고 밑그림만 그려져 있는 ‘기본 설계도’라고 할수 있다.인터페이스도 추상클래스처럼 완성되지 않은 불완전한 것이기 때문에 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다. 

## 인터페이스 작성 

```java
	 interface 인터페이스이름 {
			public static final 타입상수 이름 = 값;
			public abstract 메서드이름(매개변수목록);  
}

```
일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.  
> 모든 멤버변수는 public static final 이어야하며, 이를 생략할 수 있다.  
> 모든 메서드는 public abstract 이어야 하며, 이를 생략할수 있다.  
> 단, static메서드와 디폴트 메서드는 예외. 

## 인터페이스 상속  
인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터.  
상속을 받는 것이 가능하다. 

## 인터페이스 구현  
인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것 처럼  
인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 하는데, 그 방법은 추상클래스가 자신을 상속받는 클래스를 정의하는 것과 다르지 않다.  
다만 클래스는 확장한다는 의미의 키워드는 'extends'를 사용하지만 인터페이스는 구현한다는 의미의 키워드는 'implements'를 사용할 뿐이다.   

```java
class 클래스이름 implements 인터페이스이름 {
	//인터페이스에 정의된 추상메서드를 구현해야한다.  
}
class Figter implements Fightable {
	public void move(int x, int y) {생략}
	public void attack(Unit u) 	{생략} 
}
//만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면 , abstract를 붙여서 추상클래스로 선언해야 한다.  

abstract class Fighter implemets Fightable {
	public void move(int x, int y) {생략}
	public void attack(Unit u) 	{생략}  
}
//그리고 다음과 같이 상속과 구현을 동시에 할 수 있다.  
class Fighter extends Unit implements Fightable {
	public void move(int x, int y) {생략}
	public void attack(Unit u) 	{생략} 
}



참고- 인터페이스의 이름에는 주로 Fightable과 같이 '~을 할 수 있는'의 의미인 able로 끝나는 것들이 많은데 그 이유는 어떠한 기능 또는  
행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다. 또한 그 인터페이스를 구현하는 클래스는 '~를 할 수 있는 '능력을 갖추었다는  
의미이기도 하다. 이름이 'able'로 끝나는 것은 인터페이스라고 추측할수 있지만, 모든 인터페이스의 이름이 반드시 'able'로 끝나야 하는 것은 아니다.  

```

```java
package javatest;

class FighterTest {
	public static void main(String[] args) {
		Fighter f = new Fighter();

		if (f instanceof Unit)	{		
			System.out.println("f는 Unit클래스의 자손입니다.");
		}
		if (f instanceof Fightable) {	
			System.out.println("f는 Fightable인터페이스를 구현했습니다.");
		}
		if (f instanceof Movable) {		
			System.out.println("f는 Movable인터페이스를 구현했습니다.");
		}
		if (f instanceof Attackable) {	
			System.out.println("f는 Attackable인터페이스를 구현했습니다.");
		}
		if (f instanceof Object) {		
			System.out.println("f는 Object클래스의 자손입니다.");
		}
	}
}

class Fighter extends Unit implements Fightable {
	public void move(int x, int y) { /* 내용 생략 */ }
	public void attack(Unit u) { /* 내용 생략 */ }
}

class Unit {
	int currentHP;	// 유닛의 체력
	int x;			// 유닛의 위치(x좌표)
	int y;			// 유닛의 위치(y좌표)
}

interface Fightable extends Movable, Attackable { }
interface Movable {	void move(int x, int y);	}
interface Attackable {	void attack(Unit u); }
```
실행결과:  
f는 Unit클래스의 자손입니다.  
f는 Fightable인터페이스를 구현했습니다.  
f는 Movable인터페이스를 구현했습니다.  
f는 Attackable인터페이스를 구현했습니다.  
f는 Object클래스의 자손입니다.  



