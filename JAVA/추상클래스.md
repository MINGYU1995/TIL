# ✏추상클래스  

클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 미완성 설계도란, 단어의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다.  
클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.  
미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다.  

*추상 클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.   

실생활에서 예를 들면, 같은 크기의 Tv라도 기능의 차이에 따라 여러 종류의 모델이 있지만, 사실 이들의 설계도는 아마 90프로 정도는 동일 할 것이다.  
서로 다른 세 개의 설계도를 따로 그리는 것보다 이들의 공통부분만을 그린 미완성 설계도를 만들어 놓고, 이 미완성 설계도를 이용해서 각각의 설계도를  
완성하는 것이 훨씬 효율적일 것 이다.  

추상클래스는 키워드 'abstract'를 붙이기만 하면 된다. 이렇게 함으로써 이 클래스를 사용할 때 클래스 선언부의 abstract를 보고 이 클래스에는 
추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있을 것이다.  

참고- 추상메서드를 초함하고 있지 않은 클래스에도 키워드 abstract를 붙여서 추상클래스로 지정할 수도 있다. 추상메서드가 없는 완성된  
클래스라 할지라도 추상클래스로 지정되면 클래스의 인스턴스를 생성할 수 없다.  

## 추상메서드  
메서드는 선언부와 구현부(몸통)로 구성되어 있다고 했다. 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.  
즉, 설계만 해놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.   
메서드를 이와 같이 미완성 상태로 남겨 놓는 이유는? 메서드의 내용이 상속받는 클래스에 따라 달라질수 있기 때문이다.  
그래서 추상 클래스를 상속받는 자손 클래스는 조상의 추상 메서드를 상황에 맞게 적절히 구현해주어야 한다.  

> /*주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
> abstract 리턴타입 메서드이름();  
추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다.  
만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.  

## 추상클래스의 작성  
상속이 자손클래스를 만드는제 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것이라고 할수 있다.  
추상화의 반댓말 구체화  
> 추상화: 클래스간의 공통점을 찾아내서 공통의 조상을 만든는 작업  
> 구체화: 상속을 통해 클래스를 구현 확장하는 작업  
*굳이 abstract를 붙여서 추상메서드로 선언하는 이유는? 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.  
만일 추상메서드로 정의되어 있지 않고 위와 같이 빈 몸통만 가지도록 정의되어 있다면,,,상속받는 자손 클래스에서는 이 메서드들이 온전히  
구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있기 때문이다. 하지만 abstract를 사용해서  
추상메서드로 정의해놓으면, 자손 클래스를 작성할 때 이들이 추상메서드이므로 내용을 구현해주어야 한다는 사실을 인식하고 자신의 클래스에  
알맞게 구현할 것이다. 알기쉽게 기존의 클래스로부터 공통된 부분을 뽑아내서 추상클래스를 만들어 보도록 하자 .  

```java
class Marin { //보병  
    int x, y; //현재위치  
    void move(int x,int y) {//지정된 위치로이동}
    void stop()            {//현재 위치에 정지}  
    void stimPack()        {//스팀팩을 사용한다}  
}
class Tank {  //탱크 
    int x,y; //현재위치
    void move(int x,int y) {//지정된 위치로이동}
    void stop()            {//현재 위치에 정지}  
    void changeMode()      {공격모드를변환한다}
}
class Dropship {  //수송선 
    int x,y; //현재위치
    void move(int x,int y) {//지정된 위치로이동}
    void stop()            {//현재 위치에 정지}  
    void load()            {//선택된 대상을 태운다}
    void unload()          {//선택된 대상을 내린다}
```
유명한 컴퓨터 게임에 나오는 유닛들을 클래스로부터 간단히 정의해보았다. 이 유닛들은 각자 나름대로의 기능을 가지고 있지만.  
공통부분을 뽑아내어 하나의 클래스로 만들고, 이 클래스로부터 상속받도록 변경해보자  

```java
abstract class Unit {
      int x,y;
      abstract void move(int x, int y);
      void stop() {     //현재 위치에 정지}
}
class Marine extends Unit {   //보병  
    void move(int x, int y)  {지정된위치로 이동}
    void stimPack()          {스팀팩사용}
 }
 class Tank extends Unit { //탱크  
    void move(int x , int y) {지정된위치로 이동}
    void changeMode()        {공격모드로 변환한다.}
 }
 class Dropship extends Unit { //수송선  
    void move(int x, int y) { //지정된 위치로 이동}
    void load()
    void unload()
 } 
```
Unit[] group = new Unit[4];  
group[0] = new Marine();  
group[1] = new Tank();  
group[2] = new Marine();  
group[3] = new DropShip();  

for(int i = 0; i < group.length;i++)
    group[i].move(100,200); // <Unit배열의 모든 유닛을 좌표(100,200)의 위치로 이동한다.  
    
위의 코드는 공통 조상인 Unit클래스 타입의 참조변수 배열을 통해서 서로 다른 종류의 인스턴스를 하나의 묶으로 다룰 수 있다는 것을 보여준다.  


# 끝  
